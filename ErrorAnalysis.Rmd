---
output: html_document
---
Secondary standard Error analysis
========================================================

`r as.character(format(Sys.Date(), format="%B %d, %Y"))`





```{r Setup, echo=FALSE, warning=FALSE, message=FALSE}

#Load Libraries
require(ggplot2)
require(plyr)
require(dplyr)
require(knitr)
require(RODBC)


#Load files
source("~/R/dbconfig.R") #DB connection info
source("CalculateSecondaries.R") #Functions

#set parameters
from <- '2014-09-01'
to <- 'present' #present or date
sys <- 'both' #cfams, usams, ams1 or both
size <- c(40,200)

#Set digits for output
options(digits=4)

#Open DB connection
db <- odbcConnect(database, uid = uid, pwd = pwd)

###
#Make intcal table
###

#get intcal table

#this doesn't work on Linux. No idea why...
#intcal <- sqlFetch(db, "intercal_samples")

#This does...
intcal <- sqlQuery(db, paste("select * from ", "intercal_samples"))

#create factor of tiri_id, order by Fm
intcal <- within(intcal, name <- factor(tiri_id, levels = unique(tiri_id[order(fm_consensus, tiri_id)]),ordered = TRUE))

#Replace C-6 with new consensus from Xiaomei 2010
intcal$fm_consensus[intcal$rec_num == 1086] <- 1.5016

#add in OX-I, OX-II
ox <- read.csv("intcalox.csv")
#ox <- filter(ox, rec_num != 113385) #but don't use normalizing ox-I
intcal <- rbind(intcal, ox)


###
#get secondary data
###

out <- calcSecondaries(from, to, sys, intcal, db)

#Close DB
odbcClose(db)

#add %err
out$finterr <- out$f_int_error/out$f_modern
out$fexterr <- out$f_ext_error/out$f_modern
out$fmaxerr <- out$merr/out$f_modern
out$errrat <- out$merr/abs(out$fmd)

#select data by Fm, size, and date
out.c <- subset(out, f_modern > .1 & f_modern < 1.6)

#clean out bad data points
out.c <- subset(out.c, is.na(q_flag)) #Check for q_flag
out.c <- subset(out.c, sigma < 10 & sigma > -10) #Select reasonable sigmas
out.c <- subset(out.c, normFm < 0.02 & normFm > -0.02) #Select reasonable Fm
out.s <- subset(out.c, gf_co2_qty > size[1] & gf_co2_qty < size[2]) #Select size range
```

Analysis of performance of all secondary standards for `r sys` from `r from` to `r to`. Sample size is from `r size[1]` to `r size[2]`umol, outliers have been removed by sigma (-10 to 10) and normalized Fm (-0.02 to 0.02), and only secondaries Fm > .1 used.



Normalized fm difference is defined as:

$\frac{Fm_{m}-Fm_{c}}{Fm_{c}}$

where $Fm_{m}$ is measured Fm and $Fm_{c}$ is consensus Fm.


# Summary table


## By Secondary and System

Calculations of intrinsic error are added in below. "Intrerr" is the intrinsic error for data without normalizing Fm, and fintrerr is the intrinsic error calclulated for normalized data. Intrinsic error is calculated as follows:

$\sigma_{int}=\sqrt{\sigma_{tot}^2-\sigma_{tgt}^2}$

where $\sigma_{int}$ is the "intrinsic" error, $\sigma_{tot}$ is the total error and $\sigma_{tgt}$ is the "reported" or per-target error. $\sigma_{tot}$ is assumed to be the standard deviation of measurements of a secondary, and the mean of reported errors for a secondary is used for $\sigma_{tgt}$.

All values of NaN are cases where $\sigma_{tot}<\sigma_{tgt}$, ie. the mean reported error is greater than the actual population error.


```{r, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

#Make summary table
secsum <- ddply(out.s, .(name, system), summarize,
                fm.e = mean(fm_consensus),
                fm = mean(f_modern),
                fm.s = sd(f_modern),
                err = mean(merr),
                intrerr = intrErr(sd(f_modern), mean(merr)),
                nFm = mean(normFm),
                nFm.s = sd(normFm),
                ferr = mean(fmaxerr),
                fintrerr = intrErr(sd(normFm), mean(fmaxerr)),
                N = length(f_modern))


knitr::kable(secsum, digits = 4, caption = "Summary data for all secondaries")
# require(xtable)
# 
# table <- xtable(secsum)
# digits(table) <- 4
# 
# print(table, floating=TRUE, type="html")
```

## By System

Same as above, only the grand total by system.

```{r, echo=FALSE, message=FALSE,}

#Make summary table
syssum <- ddply(out.s, .(system), summarize,
                nFm = mean(normFm),
                nFm.s = sd(normFm),
                ferr = mean(fmaxerr),
                fintrerr = intrErr(sd(normFm), mean(fmaxerr)),
                N = length(f_modern))

knitr::kable(syssum, digits = 4, caption = "Summary data for secondaries")

```

# Calculating intrinsic error on a per sample basis

## Using all secondary data

Intrinsic errors are calculated per-sample using the per-sample reported error, $\sigma_{tgt}$ and the standard deviation of all measurements of that secondary sorted by system.

```{r, psintrinsic echo=FALSE, message=FALSE, warning=FALSE}

secsumu <- filter(secsum, system == "USAMS")
secu <- filter(out.s, system == "USAMS")
secu <- left_join(secu, secsumu, by="name")
secu <- mutate(secu, intrinsic = intrErr(fm.s, merr))
secu <- mutate(secu, fintrinsic = intrErr(nFm.s, fmaxerr))

secsumc <- filter(secsum, system == "CFAMS")
secc <- filter(out.s, system == "CFAMS")
secc <- left_join(secc, secsumc, by="name")
secc <- mutate(secc, intrinsic = intrErr(fm.s, merr))
secc <- mutate(secc, fintrinsic = intrErr(nFm.s, fmaxerr))

sec <- bind_rows(secu,secc)

intsum <- ddply(sec, .(name, system.y), summarize,
                fm.e = mean(fm_consensus),
                fm = mean(f_modern),
                fm.s = sd(f_modern),
                err = mean(merr),
                int = mean(intrinsic),
                nFm = mean(normFm),
                nFm.s = sd(normFm),
                ferr = mean(fmaxerr),
                fintrerr = mean(fintrinsic),
               N = length(f_modern))

knitr::kable(intsum, digits = 4, caption = "Summary data for secondaries")
```

## By System

Same as above, only the grand total by system. Only cases where $\sigma_{tot}<\sigma_{tgt}$, ie. the mean reported error is greater than the actual population error are used. This biases the intrinsic error heavily towards data from higher Fm samples. THis also reduces N for CFAMS due to higher reported errors on low Fm samples.

```{r, echo=FALSE, message=FALSE,}

#Make summary table
sec <- select(sec, system.y, normFm, fmaxerr, fintrinsic, f_modern)
sec <- sec[complete.cases(sec),]
syssum <- ddply(sec, .(system.y), summarize,
                nFm = mean(normFm),
                nFm.s = sd(normFm),
                ferr = mean(fmaxerr),
                fintrerr = mean(fintrinsic),
                N = length(f_modern))

knitr::kable(syssum, digits = 4, caption = "Summary data for secondaries")

```

# Intrinsic error using normalizing OX-I

The proposed method for calculating intrinsic error is to use normalizing ox-I's and calculate the correction by system and use either a time period or make the calculation by wheel.

Let's look at it by wheel.

```{r, echo=FALSE, message=FALSE,}

ierrs <- out.s %>% filter(rec_num == 113385) %>% group_by(wheel_id) %>% summarise(fm.s = sd(f_modern))


```
